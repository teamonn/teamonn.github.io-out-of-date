[{"title":"10个JavaScript难点【转】","date":"2017-12-29T13:02:00.000Z","path":"2017/12/29/10-difficulty-of-js/","text":"转自一篇来自知乎专栏的从国外翻译过来的文章。文章很好，看完后能让人产生一种“拜读”的感觉！ 原文：10 JavaScript concepts every Node.js programmer must master译者：Fundebug 为了保证可读性，本文采用意译而非直译，并且对示例代码进行了大量修改。另外，本文版权归原作者所有，翻译仅用于学习。 1. 立即执行函数立即执行函数，即 Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：1234(function() &#123; // 代码 // ...&#125;)(); function(){…} 是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数 最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。 2. 闭包对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。 123456789101112function f1() &#123; var N = 0; // N是f1函数的局部变量 function f2 () &#123; // f2是f1函数的内部函数，是闭包 N += 1; // 内部函数f2中使用了外部函数f1中的变量N console.log(N); &#125; return f2;&#125;var result = f1();result(); // 输出1result(); // 输出2result(); // 输出3 代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！ 3. 使用闭包定义私有变量通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量： 12345678910111213function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName(\"Fundebug\");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出Fundebug 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 4. prototype每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。 1234567891011121314function Rectangle(x, y) &#123; this._length = x; this._breadth = y;&#125;Rectangle.prototype.getDimensions = function()&#123; return &#123; length: this._length, breadth: this._breadth &#125;;&#125;;var x = new Rectangle(3, 4);var y = new Rectangle(4, 3);console.log(x.getDimensions()); // &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125; 代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。 5. 模块化JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及我们Fundebug都是这样实现的。 12345678910111213141516var module = (function() &#123; var N = 5; function print(x) &#123; console.log(\"The result is: \" + x); &#125; function add(a) &#123; var x = a + N; print(x); &#125; return &#123; description: \"This is description\", add: add &#125;;&#125;)();console.log(module.description); // 输出\"this is description\" module.add(5); // 输出“The result is: 10” 所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。 6. 变量提升JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。 但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错： 12console.log(y); // 输出undefinedy = 2; // 初始化y 上面的代码等价于下面的代码：123var y; // 声明yconsole.log(y); // 输出undefinedy = 2; // 初始化y 为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。 7. 柯里化柯里化，即Currying，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。 12345678910var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11 代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。 8. apply, call与bind方法JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。 三者之中，call方法是最简单的，它等价于指定this值调用函数： 1234567891011var user = &#123; name: \"Rahul Mhatre\", whatIsYourName: function() &#123; console.log(this.name); &#125;&#125;;user.whatIsYourName(); // 输出\"Rahul Mhatre\",var user2 = &#123; name: \"Neha Sampat\"&#125;;user.whatIsYourName.call(user2); // 输出\"Neha Sampat\" apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定： apply(thisArg, [argsArray]) call(thisArg, arg1, arg2, …) 1234567891011var user = &#123; greet: \"Hello!\", greetUser: function(userName) &#123; console.log(this.greet + \" \" + userName); &#125;&#125;;var greet1 = &#123; greet: \"Hola\"&#125;;user.greetUser.call(greet1, \"Rahul\"); // 输出\"Hola Rahul\"user.greetUser.apply(greet1, [\"Rahul\"]); // 输出\"Hola Rahul\" 使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：12345678910var user = &#123; greet: \"Hello!\", greetUser: function(userName) &#123; console.log(this.greet + \" \" + userName); &#125;&#125;;var greetHola = user.greetUser.bind(&#123;greet: \"Hola\"&#125;);var greetBonjour = user.greetUser.bind(&#123;greet: \"Bonjour\"&#125;);greetHola(\"Rahul\") // 输出\"Hola Rahul\"greetBonjour(\"Rahul\") // 输出\"Bonjour Rahul\" 9. MemoizationMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。 12345678910111213141516171819202122function memoizeFunction(func)&#123; var cache = &#123;&#125;; return function() &#123; var key = arguments[0]; if (cache[key]) &#123; return cache[key]; &#125; else &#123; var val = func.apply(this, arguments); cache[key] = val; return val; &#125; &#125;;&#125;var fibonacci = memoizeFunction(function(n)&#123; return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;);console.log(fibonacci(100)); // 输出354224848179262000000console.log(fibonacci(100)); // 输出354224848179262000000 代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。 10. 函数重载所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。 从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。 难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。 由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。 根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function addMethod(object, name, f)&#123; var old = object[name]; object[name] = function() &#123; // f.length为函数定义时的参数个数 // arguments.length为函数调用时的参数个数 if (f.length === arguments.length) &#123; return f.apply(this, arguments); &#125; else if (typeof old === \"function\") &#123; return old.apply(this, arguments); &#125; &#125;;&#125;// 不传参数时，返回所有namefunction find0()&#123; return this.names;&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++) &#123; if (this.names[i].indexOf(firstName) === 0) &#123; result.push(this.names[i]); &#125; &#125; return result;&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++) &#123; if (this.names[i] === (firstName + \" \" + lastName)) &#123; result.push(this.names[i]); &#125; &#125; return result;&#125;var people = &#123; names: [\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]&#125;;addMethod(people, \"find\", find0);addMethod(people, \"find\", find1);addMethod(people, \"find\", find2);console.log(people.find()); // 输出[\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]console.log(people.find(\"Dean\")); // 输出[\"Dean Edwards\", \"Dean Tom\"]console.log(people.find(\"Dean\", \"Edwards\")); // 输出[\"Dean Edwards\"] 参考文章： 闭包 - MDN JS函数式编程指南","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xuzhengmao.com/tags/javascript/"}]},{"title":"重识 HTTP","date":"2017-11-20T13:25:30.000Z","path":"2017/11/20/understand-http/","text":"HTTP 是网络应用层协议，是万维网数据通信的基础。最初它是用来提供一种服务器端发布和浏览器端接收 HTML 页面的方法。 HTTP 请求报文结构一个 http 请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求正文（request-body）4个部分组成。 请求行：由 请求方法、URL 和 http协议版本 3个字段组成。 请求头：请求头部由键值对组成，每行一对，关键字和值用英文冒号“：”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：User-Agent（请求的浏览器类型）、Accept（客户端可识别的内容类型列表）、Host（请求的主机名，允许多个域名同处一个IP地址，即虚拟主机）。 空行：最后一个请求头之后是一个空行，发送回车符 和换行符，通知服务器以下不再有请求头。 请求正文：请求参数，它不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。 HTTP 响应报文结构HTTP响应也由3个部分组成，分别是：状态行（status line）、消息报头（headers）、响应正文（response body）。 http 响应报文 与 请求报文 的对比： 状态行：服务器HTTP协议的版本 + 响应状态码 + 状态码的文本描述，如HTTP/1.1 200 OK。 消息报头：用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。如：服务器支持哪些请求方法、文档编码方法（Content-Encoding）、内容长度（Content-Length）、内容文档类型（Content- Type）、当前时间、缓存信息等。 响应正文：可能是一个html页面或片段，也可能只是一段纯数据或js代码。 8种http请求方法 GET：向指定的资源发出“显示”请求，应只用在读取数据，而不应当被用于产生“副作用”的操作中。 HEAD：同GET方法，都是向服务器发出指定资源的请求。它可以在不必传输全部内容的情况下，获取其中“关于该资源的信息”。 POST：向指定资源提交数据，请求服务器进行处理（例：提交表单、上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 OPTIONS：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405，当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501。 HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。 响应报文状态码 状态码 含义 例子 1xx 指示信息–表示请求已接收，继续处理 2xx 成功–表示请求已被成功接收、理解、接受 HTTP/1.1 200 OK 3xx 重定向–要完成请求必须进行更进一步的操作 4xx 客户端错误–请求有语法错误或请求无法实现，如请求链接为不存在 HTTP/1.1 404 Not Found 5xx 服务器端错误–处理某个正确请求时发生错误 常见状态代码含义如下： 200 OK：客户端请求成功。 204 No Content：服务器成功处理了请求，但没有返回任何内容。 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。 http/2 与 http/1.1 的区别 对HTTP头字段进行数据压缩(即HPACK算法)； HTTP/2 支持 服务端推送 (Server Push)； 请求 管线化； 修复HTTP/1.0版本以来未修复的 队头阻塞 问题； 对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内。 HTTP/2 高度兼容 HTTP/1.1 的用法。它的请求方法、状态码乃至url和绝大多数http头部字段一致，并支持新特性来让你获得更快的速度。 GET 和 POST 的区别 GET请求的数据附在URL之后，POST提交的数据是放置在HTTP包着的＜request-body＞中。 传输数据的大小不同。GET长度最大是2048个字符，POST无限制。 安全性不同。GET提交的参数将明文出现在URL上，存在安全隐患。 GET能缓存，POST不能缓存。 后退页面的动作不同。GET无害，POST会再次重新提交页面请求。 使用http好久了，但是之前却没有好好花时间系统整理下这块的知识点。虽然说的可能都是别人说过的，但是他山之石可攻玉。就当是作为自己学习http协议的一个总结和回顾吧！ 推荐参考和学习的资料： HTTP请求报文和HTTP响应报文 HTTP MDN文档","tags":[{"name":"http","slug":"http","permalink":"http://xuzhengmao.com/tags/http/"}]},{"title":"PM2 从入门到“放弃”","date":"2017-09-18T08:23:31.000Z","path":"2017/09/18/study-pm2/","text":"“世上无难事，只要肯放弃”。 ：） 本文主要是记录笔者学习PM2后的一种知识回顾和梳理，而不是入门教程。（入门资料见文章底部） 简介pm2 是一个Node应用的进程管理器。 你可以把它理解成是一种命令行管理工具，利用它可以简化很多node应用管理的繁琐任务。 特性 内建负载均衡（使用 Node cluster 集群模块，可参考朴灵的《深入浅出node.js》第九章） 后台运行 0秒停机重载，即 允许你重新载入代码而不用失去请求连接 跨平台支持，具有 Ubuntu 和 CentOS 的启动脚本 停止不稳定的进程（避免无限循环） 控制台性能检测 提供 HTTP API 远程控制和实时的接口 API ( Nodejs 模块，允许和 PM2 进程管理器交互 ) 常用用法12345678910111213141516171819$ npm install pm2 -g # 命令行安装 pm2 $ pm2 start app.js -i 4 # 后台运行pm2，启动4个app.js (负载均衡) # 也可以把'max' 参数传递给 start # 正确的进程数目依赖于Cpu的核心数目$ pm2 start app.js --name my-api # 命名进程$ pm2 start app.json # 启动进程, 在app.json里设置选项（启动的参数说明下面会提到）$ pm2 list # 显示所有进程状态$ pm2 monit # 监视所有进程的CPU和内存的实时使用情况$ pm2 logs # 显示所有进程日志$ pm2 stop all # 停止所有进程$ pm2 restart all # 重启所有进程$ pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程)$ pm2 describe 0 # 常看指定应用详细的运行状态$ pm2 stop 0 # 停止指定的进程$ pm2 restart 0 # 重启指定的进程$ pm2 startup # 产生 init 脚本 保持进程活着$ pm2 web # 开启api访问 (浏览器访问 http://localhost:9615)$ pm2 delete 0 # 杀死指定的进程$ pm2 delete all # 杀死全部进程 启动参数1$ pm2 start app.js &lt;参数&gt; 参数列表 —watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i —instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 —ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如–ignore-watch=”test node_modules “some scripts”” -n —name：应用的名称。查看应用信息的时候可以用到。 -o –output ：标准输出日志文件的路径。 -e –error ：错误输出日志文件的路径。 —interpreter ：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。 结语学习，是一场孤独的旅行。但我相信，每个忠于自己爱好和兴趣的人，一定能走到最后。 参考资料:1- PM2介绍 - 怪石羽笺2- PM2实用入门指南 - IMWeb社区3- 使用pm2躺着实现负载均衡","tags":[{"name":"后端","slug":"后端","permalink":"http://xuzhengmao.com/tags/后端/"}]},{"title":"全面学习JS对象","date":"2017-08-03T11:26:14.000Z","path":"2017/08/03/study-js-object/","text":"有一天，前端菜鸟问老鸟问题。 菜鸟：什么是对象啊？老鸟：有句话不知当讲不当讲？菜鸟：请讲。老鸟：佛说，万物皆为对象！菜鸟：…#@&amp;%! 开个玩笑。Web前端开发，JavaScript是核心。而JavaScript中，对象相关的知识又是核心。 所以，对于一个前端开发者来说，学习好JS对象知识是必不可少的。 对象的基本结构对象，是一组由若干个无序键值对（key: value）组成的数据集合。 在 javascript 中，所有的数据都可以被视作对象。在某个对象中，每一个键值对叫做成员，键名叫做属性或者方法。 如何构造对象、复制对象（深拷贝）、访问或者删除对象属性常见几种构造对象方法：123456789101112131415161718192021222324252627282930313233// 方法1，创建字面量var person = &#123; name: 'rain', age: 25&#125;// 方法2，定义对象实例var person = new Object();person.name = 'rain';person.age = 25;// 方法3，工厂模式function createPerson(name, age)&#123; var o = new Object(); o.name = name; o.age = age; return o;&#125;var person = createPerson('rain', 25);// 方法4，构造函数模式function Person(name, age)&#123; this.name = name; this.age = age;&#125;var person = new Person('rain', 25);// 方法5，原型模式var person = Object.create(Object.prototype, &#123; name: &#123; value: 'rain' &#125;, age: &#123; value: 25 &#125;&#125;) 复制对象JavaScript中对象（或数组）与其他基础数据类型不同，它的引用是按址引用。的。如果直接使用等号简单复制，会造成不同的变量引用同一个对象，即它们会指向同一个内存地址。修改其中一个变量，其他的变量就会跟着一起改变。解决办法就是对象深拷贝。var newObj = Object.assign({}, obj)方法是伪深拷贝，它只能深拷贝对象第一层子属性。var newObj = JSON.parse( JSON.stringify(obj) )方法是深拷贝，但是只能深拷贝对象的属性，对象的方法在拷贝过程中会被丢掉。所以真正的深拷贝是需要自己实现的，可以通过递归调用浅拷贝，一层层复制一个对象的子代属性来实现。参见：JavaScript 的深拷贝和浅拷贝 访问对象属性读取属性有两种方法，一种是点运算符（对象点属性/方法即可拿到一个对象的某个属性值或方法），一种是方括号运算符。方括号运算符可以使用表达式，也可以读取键名为数字、不符合标识符条件的、关键字和保留字的属性。对象的属性本质是一个字符串，加不加引号都可以。Object.keys(obj)可以遍历 obj 所有可以枚举的属性，返回所有可枚举自身属性的属性名组成的数组。 删除对象属性delete person.name即删除掉person对象的name属性。 面向OOP编程JavaScript 是一门彻底的面向对象的语言。它在ES6之前没有类（class）的概念，它是基于原型来面向对象的。 基于类的面向对象 VS 基于原型的面向对象 在 基于类的面向对象 方式中，对象（object）依靠 类（class）来产生。而在 基于原型的面向对象 方式中，对象（object）则是依靠 构造器（constructor）利用 原型（prototype）构造出来的。就像工厂要造一辆车，一方面，工人必须参照一张工程图纸，设计规定这辆车应该如何制造。这里的工程图纸就好比是语言中的 类 (class)，而车就是按照这个 类（class）制造出来的；另一方面，工人和机器 ( 相当于 constructor) 利用各种零部件如发动机，轮胎，方向盘 ( 相当于 prototype 的各个属性 ) 将汽车组装出来。 JavaScript如何实现对象的继承？JavaScript无法实现接口继承，只支持实现继承，所以它主要是依靠原型链来实现继承的。 原型方法（将父类的实例作为子类的原型，Cat.prototype = new Animal()） 借用构造函数（借父类的构造函数来增强子类实例，子类构造函数中通过call/apply方法把this传到父类） 原型链方式/实例继承（子类通过prototype将所有在父类中通过prototype追加的属性和方法都追加到Child） 拷贝继承（子类构造函数里面逐个拷贝父类属性） 组合继承（把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点） 寄生组合继承（切掉了原型对象上多余的那份父类实例属性）（见 《JavaScript高级程序设计 第3版》第6章 继承） 值引用和对象引用程序中变量分为两种，一种计算机存储的是这个变量的值（值引用），一种存储的是这个变量在计算机内存中的地址（对象引用）。与其他简单数据类型不同，数组和对象的引用是按址引用的。如果不同的变量引用同一个对象，它们会指向同一个内存地址，修改其中一个变量，会影响到其它的变量。 上面讲到的 浅拷贝 和 深拷贝 就是 值引用 和 对象引用 区别的具体体现。 原型对象（prototype和__proto__）、原型链、作用域链、闭包构造函数、原型和实例的关系:每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 12345function Person (n) &#123; // 构造函数 this.name = n;&#125;var me = new Person('rain'); // me 是实例对象me.__proto__ === Person.prototype; // true 简单来讲原型对象是用来指导某个构造函数来构造对应对象的父对象。这些原型对象一层层嵌套，形成一个链条，就叫原型链。JavaScript 主要通过原型链实现继承。 所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。但原型链的顶点是null，而不是Object.prototype。原型链上只能有对象。 作用域：程序中函数或者变量的作用范围，可以是局部，也可以是全局。作用域链：各个函数作用域的相互嵌套会形成函数作用域链。当在自身作用域内找不到该变量的时候，会沿着作用域链逐步向上查找，若在全局作用域内部仍找不到该变量，则会抛出异常。闭包：在一个函数的内部创建另外一个函数。当外部函数被调用的时候，内部函数也就随着创建，这样就形成了闭包。作用是 —— 用来实现在一个函数作用域中访问另一个函数作用域的变量或方法。 this指向问题(apply/call/bind)this用法很多，不同场合this指向不同。 普通函数调用：浏览器宿主的全局环境中，this指的是window对象 作为对象的方法来调用：this就指向这个被调用方法的父对象 作为构造函数来调用：this指向这个新构造出来的新对象 使用apply/call方法来调用：this指的就是第一个参数（func.call(this, arg1, arg2)，func.apply(this, [arg1, arg2])） bind方法：创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 es6箭头函数：绑定this为定义时所在的作用域，而不是运行时所在的作用域(因为箭头函数根本没有自己的this)1234567891011121314151617181920212223242526// call方法(apply类似)function cat()&#123; this.food = \"fish\"; this.say = function()&#123; console.log(\"I love \" + this.food); &#125;&#125;var blackCat = new cat();blackCat.say(); // I love fishvar whiteDog = &#123; food: \"bone\"&#125;blackCat.say.call(whiteDog); // I love bone 这样让whiteDog也能调用blackCat的say方法// bind方法var x = 1;var obj = &#123; x: 2, getX: function()&#123; console.log(this.x); &#125;&#125;console.log(obj.getX()); // 2var oldObj = obj.getX;oldObj(); // 1 oldObj暴露在全局作用域，oldObj的this指向的是windowvar newObj = obj.getX.bind(obj); // 用bind将obj.getX的this指向绑定为obj的this指向newObj(); // 2 最后的小结由于公司业务也比较忙，这边文章（其实就是我个人的学习笔记）我差不多整理了3个晚上。之前初学 JavaScript 太过走马观花，没有脚踏实地好好学习原生JS的基础知识。导致工作一年来，越来越觉得基础的重要性。趁现在还能亡羊补牢，赶紧抽时间把JS的基础知识好好系统过一遍吧！ 毕竟，磨刀不误砍柴工。 推荐参考和学习的资料： 《JavaScript高级程序设计 第3版》 《JavaScript语言精粹》 《你不知道的JavaScript 上》 mozilla开发者文档 MDN 《阮一峰 ES6教程》","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xuzhengmao.com/tags/javascript/"}]},{"title":"谈谈那些值得被简化的 JS 代码","date":"2017-07-11T07:21:33.000Z","path":"2017/07/11/The-JavaScript-code-that-is-worth-simplifying/","text":"最近这段时间写 JavaScript 的代码感觉略有心得，所以就想把自己平时积累的一些知识点整理分享出来，跟大家粗浅的谈一谈 JavaScript 中有哪些代码可以简化，让它变得更优雅。 1. 非空校验 / 短路运算我们经常会遇到把一个变量 a 赋值给变量 b 的情况。但是值得注意的是，一般都要进行非空的判断。不然把 null 或者 undefined 赋值给了 b，当后面使用 b 的时候就会报错。 简化前： 123if (a !== null &amp;&amp; a !== undefined) &#123; let b = a;&#125; 简化后： 1let b = a || ''; 巧妙运用逻辑短路运算，当 a 值为 null 或者 undefined 的时候，「或」的前半部分都是假，而此时「或」的后半部分值是真，则 b 被赋值为空字符串。 2. 三目运算符的使用简化前： 123456let big;if (x &gt; 10) &#123; big = true;&#125; else &#123; big = false;&#125; 简化后： 1let big = x &gt; 10 ? true : flase; 这是我们开发中很常见的情景，if…else 大家都很容易想到，但用上三目运算符后代码既简洁，又高效。 3. 优化 if…elseif…else 既要尽量使用三目运算符替代，也要优化它本身。 简化前： 1234// 当 c 是假值的时候，执行某些操作if (c === false) &#123; // do something...&#125; 简化后： 123if (!c) &#123; // do something...&#125; 4. 自增自减等假设 count1、count2、count3、count4、x 均已被赋值 12count1 = count1 + 1;count2 = count2 - 1; 这种很多人都知道可以简化成 12count1++;count2--; 但是如果自增、自减的值不是 1，而是一个变量 x 时又该怎么写？ 简化前： 1234count1 = count1 + x;count2 = count2 - x;count3 = count3 * x;count4 = count4 / x; 简化后： 1234count1 += x;count2 -= x;count3 *= x;count4 /= x; 5. 多用 RegExp 隐式声明如，用正则匹配3个连续的数字 简化前： 123let reg = new RegExp(\"[0-9]&#123;3&#125;\",\"ig\");let result = reg.exec(\"padding666padding\");console.log(result[0]); // 666 简化后： 12let result = /[0-9]&#123;3&#125;/ig.exec(\"padding666padding\");console.log(result[0]); // 666 这样写的好处不仅在于代码更简洁，而且少使用一个变量，减小了内存的开销。 6. 字符串取值当成数组处理例如 let str = &#39;myString&#39;，怎么快速取到字符串 str 的首字母？ 简化前： 1str.charAt(0); // m 简化后： 1str[0]; // m 既然字符串可以当成数组来用下标取值，为什么我们不选择这种更高的姿势呢? 7. 箭头函数假设有一个数组 let nums = [4, 8, 1, 9, 0]; 现在需要将它的每个元素都变成之前2倍 简化前： 1234for (let i in nums) &#123; nums[i] *= 2;&#125;console.log(nums) //输出 [8, 16, 2, 18, 0] 简化后： 12nums.map(i =&gt; 2 * i)console.log(nums) //输出 [8, 16, 2, 18, 0] 箭头函数是 ES6 的内容，ES6 已经发展多年，兼容性也比较好了。既然它就是为了解放我们开发者劳动力的，那么我们还有什么理由不去使用更好、更快、更简洁的写法呢？ 除了箭头函数，这个例子还使用了 Array 的 map 方法。它是比用 for 循环来遍历数组更佳的写法，不熟悉的同学可以自行查阅。 8. 优雅的表示大数平常开发中偶尔也会遇到大数赋值，怎样才是表示大数的正确姿势呢？ 简化前： 1let longNum = 1000000; 简化后： 1let longNum = 1e7; 9. 连等简化前： 1234let a = 5;let b = a + 3;let c = b;console.log(c); // 8 简化后： 123let a = 5;let c = b = a + 3;console.log(c); // 8 10. class 的使用简化前： 123456789101112function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.addAge = function () &#123; this.age++;&#125;Person.prototype.setName = function (name) &#123; this.name = name;&#125; 简化后： 123456789101112class Person &#123; constructor (name, age)&#123; this.name = name; this.age = age; &#125; addAge () &#123; this.age++; &#125; setName (name) &#123; this.name = name; &#125;&#125; 简化前是函数式编程的写法，各个方法写在外面格式显得很凌乱。用 ES6 的 class 简化后是面向对象的写法，代码显得更整洁紧凑，可以更方便的实现继承。 11. 字符串拼接let name = &#39;torain&#39;; 简化前： 12let str = 'My name is ' + name;console.log(str) // My name is torain 简化后： 12let str = `My name is $&#123;name&#125;`;console.log(str) // My name is torain 12. 提取对象属性或者属性值1234let obj = &#123; a: 1, b: 2&#125; 简化前： 123456789// 提取 obj 的所有属性for (let i in obj) &#123; console.log(i); // 依次打印出：a b&#125;// 提取 obj 的所有属性值for (let i in obj) &#123; console.log(obj[i]); // 依次打印出：1 2&#125; 简化后： 12345// 提取 obj 的所有属性keys(obj) // [\"a\", \"b\"]// 提取 obj 的所有属性值values(obj) // [1, 2] 13. !! 更快转化成逻辑值简化前： 123let num = 2;let bln = Boolean(num);console.log(bln); // true 简化后： 123let num = 2;let bln = !!num;console.log(bln); // true 转换成逻辑值的函数 Boolean() 可能不是人人都知道，所以可以通过两次逻辑求反得到一个变量的逻辑值。既快速，有方便记忆。 14. 对象解构简化前： 12345let obj = &#123; a: 3, b: 4 &#125;console.log(obj.a, obj.b); // 3 4 简化后： 123456let obj = &#123; a: 3, b: 4 &#125;let &#123; a, b &#125; = obj;console.log(a, b); // 3 4 这种 ES6 的新写法看似简洁不了多少，但在 obj 的属性有非常多的时候优势就比较明显了。而且这样把需要用到的属性都放在同一行统一解构，对于使用与没有使用的对象属性可以一览无余。 15. … 数组展开运算符假如要列举一个数组的所有的元素，可能大多数人想到的是用 for 循环遍历。 简化前： 1234let arr = [1, 2, 3];for (let i of arr) &#123; console.log(i); // 依次打印出 1 2 3&#125; 简化后： 12let arr = [1, 2, 3];console.log(...arr); // 1 2 3 更多文章，可以访问: 我的csdn博客","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xuzhengmao.com/tags/javascript/"}]},{"title":"如何优雅的获取你点击的那个 li？","date":"2017-07-09T15:55:58.000Z","path":"2017/07/09/how-to-loop-li/","text":"如果一个 ul 中有多个 li 标签，如何快速获取到你所点击的那个 li 在整个 ul 中的顺序？ 这是一道我们 web 前端程序员会经常在面试中被问到的经典考题。它看似简单却非常考察功力，因为它的解法非常多。你回答的解法，很可能会直接影响面试官对你技术水平的判定。 首先，我们假设 ul 和 li 的层级关系是这样的：1234567&lt;ul onClick=\"handleClick(event)\"&gt; &lt;li id=\"1\"&gt;li-1&lt;/li&gt; &lt;li id=\"2\"&gt;li-2&lt;/li&gt; &lt;li id=\"3\"&gt;li-3&lt;/li&gt; &lt;li id=\"4\"&gt;li-4&lt;/li&gt; &lt;li id=\"5\"&gt;li-5&lt;/li&gt;&lt;/ul&gt; 平常很多人的错误写法123456var list = document.getElementsByTagName(\"li\");for(var i = 0; i &lt; list.length; i++) &#123; list[i].onclick = function() &#123; console.log(i); &#125;&#125; 为什么说这是一个最常见的错误解法呢，因为这样你怎么点击打印出来的都是”6”。原因是这个 for 循环在你点击之前就已经执行了，i 已经到了6。而这个 for 循环形成了一个闭包，i 这个变量会暂存在内存中，直到你刷新页面之后它重新加到6。 1：jq each12345$('ul li').each(function()&#123; $(this).click(function()&#123; console.log(this.id) &#125;)&#125;) 2：js this12345$('ul li').click(function()&#123; var index = $(this).index() + 1; console.log(index); return false;&#125;) 上面两种使用 JQuery 的解法是最容易想出来，但是它借助了 Jquery，不适合考察面试者原生 JavaScript 的水平。所以你答出来一般面试官也并不会觉得有什么，他还会接着问你有没有其他的解法。 3：js setAttribute1234567var lis = document.getElementsByTagName('li');for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].setAttribute('index', i); lis[i].onclick = function()&#123; console.log(parseInt(this.getAttribute('index')) + 1); &#125; &#125; 这个解法是我第一次碰到这种题目面试想到的解法，利用标签可以自定义属性的特性，给每个 li 事先绑定一个顺序值。然后点击的时候就可以直接打印出这个你刚定义的值即可。此法简单管用，思路也比较容易想到。 4：js var -&gt; let1234567var list = document.getElementsByTagName(\"li\");// 仅把循环变量 i 改为用 let 声明即可for(let i = 0; i &lt; list.length; i++) &#123; list[i].onclick = function() &#123; console.log(i + 1); &#125;&#125; 这个解法是我学习 es6 之后才理解的，上次在网上再次搜这个面试题解法的时候看到了有人这么做的。思路是利用 es6 中 let 具有块级作用域的特点实现的。 5：js 事件委托12345function handleClick (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; console.log(target.id)&#125; 这个解法是上次别人请教我事件委托的问题，我给他讲解的过程中突然灵机一动想到了这个题目也是可以用事件委托来解答的。它主要是利用父级代理子级事件时，可以获取到子级 dom 对象。那么当然也可以获取到每个 li 的 id 属性了。 6：js 闭包12345678var lis = document.getElementsByTagName('li');for (var i = 0; i &lt; lis.length; i++) &#123; (function(j)&#123; lis[j].addEventListener(\"click\", function(e) &#123; console.log(j + 1) &#125;, false) &#125;)(i)&#125; 这个解法其实就算是高级写法了。是我上次想总结一下这个经典面试题所有解答方式的时候在网上看到别人是这么解的。我的理解得好像不是很透彻，有兴趣的可以研究下。 其实有很多经典的面试题，都是那种看似简单，实则暗藏玄机的考题。它不仅考察你技术上的灵活性，还考察了你知识上的系统性。我个人认为，其实都还是可以认真研究下的。 更多文章，可以访问: 我的csdn博客","tags":[{"name":"面试","slug":"面试","permalink":"http://xuzhengmao.com/tags/面试/"}]},{"title":"前端人眼中的九段","date":"2017-06-29T07:32:11.000Z","path":"2017/06/29/the-nine-section-in-front-end/","text":"最近流行一个段子： 三流码农写UI，二流码农写架构，一流码农写算法… 这个段子可能说得也不全对，毕竟一流程序员也不是通过算法来判定的。但它对于各个段位程序员之间水平差距的划分，好像是那么回事。 于是我联想到前两天看到了一个别人像划分围棋一样，将前端程序员划为九等的文章。看后之后我感觉有的地方分得不是很合适，就想以自己粗浅的技术经验和视野，谈一谈自己心中目前的九段。 第一段熟悉 HTML、CSS、JavaScript 基本语法，能够独立写出简单的静态网页（很有可能还是 table 布局）。简单说就是，能切图。 第二段能用 DIV 布局，还能用 JavaScript 或者 JQuery 实现一些简单有趣的动画特效了，也有可能是用别人的插件。一句话就是，能切好图。 第三段熟悉 JavaScript 的内置对象和方法。了解 http 和 web 安全方面的知识，理解前后端分离，能使用 ajax 等与服务器进行数据交互。 第四段熟悉 HTTML5 和 CSS3，能写出语义化的标签和符合 W3C 标准的页面了。能写出自定义动画，掌握 canvas、svg 等，懂浏览器差异性和兼容性。一般会搭建个人博客（可能使用 hexo），自己买服务器域名或者使用 github pages 服务。 第五段JavaScript方面，开始研究面向对象、闭包、原型原型链，并且理解函数式编程与面向对象编程的差距了。能熟悉一门服务器语言如 nodejs、php等，可以一个人写出一个基本网站的前后端了。 第六段熟悉各类 MVVM 前端框架的使用，懂得各类浏览器以及移动端开发的调试技巧，了解CSS、JS的运行机制，注重网站性能优化。能开发单页面应用，能使用各种构建工具，实现前端工程化，自动化，模块化。 第七段经常查看各类知名前端框架、类库的源码，如JQuery、loadsh、ElementUI等。经常为一些开源项目贡献自己的一份力量。 第八段开始在团队里做前端架构类的工作，主持或参与各类前端框架的编写。能跳出个人发展的局限，为团队或带领团队持续向前发展。 第九段已经步入了 HTML、CSS、JS 规范的制定，是他们引领行业的发展，决定前端的未来。 程序员水平的高低，差距其实是很大的。不光是 web 前端程序员，延伸到整个程序员行业都适用。 比如遇到一个问题时，初级程序员很可能是没有头绪，到处问人，面向QQ编程。没有资源问，就去百度搜索一大堆答案挨个试，这样最后能解决问题的几率很少。 如果是中级程序员，他会结合自己已有的经验解决。如果还是不行他就会上 Google、Stack Overflow 等地方寻找答案。这样最后问题往往都能顺利得到解决。 高级程序员遇到问题第一时间往往不是去找答案，而是会通过问题出现的场景，去分析引发问题的根源。他们是经常去查看引用的别人框架、插件、库的源码。这样的处理方式最后不能解决的问题往往极少。 哈哈，别问我是怎么知道高级程序员解决问题的方式。毕竟「没吃过猪肉，还没见过猪跑啊」。虽然我还不是高级程序员，但我身边有一些工作经验很足，技术积累很深的大神平常就是这么解决问题的。 行业内从来都没有什么固定的标准来划分前端开发水平的段位，以上也只是我个人的一个简单划分。可能理解有偏差，但是还是希望能给刚入坑的同学一个大致的方向感。 更多文章，可以访问: 我的csdn博客","tags":[{"name":"技术视野","slug":"技术视野","permalink":"http://xuzhengmao.com/tags/技术视野/"}]},{"title":"git stash 和 git stash pop","date":"2017-06-17T03:54:18.000Z","path":"2017/06/17/git-stash/","text":"git stash 可以用来暂存当前正在进行的工作。 比如，你想 pull 最新代码，又不想加新 commit 的时候。 又或者另外一种情况，为了 fix 一个紧急的 bug，先 git stash, 使返回到自己上一个 commit，改完 bug 之后再 git stash pop，继续原来的工作。 基础命令： 123git stash# do some workgit stash pop 进阶： 1git stash save \"work in progress for foo feature\" 当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，你可以输入： 1git stash list 将当前的 git 栈信息全都打印出来，你只需要将找到对应的版本号，例如使用 1git stash apply stash@&#123;1&#125; 就可以将你指定版本号为 stash@{1} 的工作取出来。当你将所有的栈都应用回来的时候，可以使用 1git stash clear 来将栈清空。 git stash apply 和 git stash pop 区别两者都可以把 git 栈里面的内容取出来，但 git stash apply 恢复后，stash 内容并不会被删除，除非你再用 git stash drop 来删除； 而用 git stash pop，它在恢复的同时把 stash 内容也删了。 相关命令12345678git stash # save uncommitted changesgit stash list # list stashed changes in this gitgit show stash@&#123;0&#125; # see the last stash git stash pop # apply last stash and remove it from the listgit stash apply # apply last stashgit stash drop # remove it from the listgit stash clear # remove the whole git stash listgit stash --help # for more info 参考资料： 廖雪峰 git 教程 - Bug分支 git 官方文档 更多文章，可以访问: 我的csdn博客","tags":[{"name":"git","slug":"git","permalink":"http://xuzhengmao.com/tags/git/"}]},{"title":"如何让你的移动网站拥有原生应用般的体验？","date":"2017-05-05T11:33:19.000Z","path":"2017/05/05/make-mobile-web-look-likes-app/","text":"众所周知移动网站在开发、迭代版本方面，比原生APP更具有优势，但是在用户体验方面却逊色很多。用户体验差表现在哪些方面呢？主要是 互动（interaction）和动画（animation）这两方面。 那么为什么我们不能把移动web的用户体验做得更好呢？这还得从web的性能瓶颈说起 … 1. 移动网站为什么不能拥有原生般的体验？阮一峰老师在他的 《也许，DOM 不是答案》一文中分析了移动 web 性能瓶颈的几个原因： Web基于DOM，而DOM加载很慢 DOM拖慢JavaScript，因为所有的 DOM 操作都是同步的，一个操作没完，后面的操作都需要等待 网页是单线程的 网页没有硬件加速，网页由CPU处理，没用GPU图形加速。 这些原因对于 PC 端 网站没有太大影响。但是手机硬件资源有限，用户互动又相对频繁，于是跟原生应用相比，自然就出现了明显的不足。 2. 怎样做，移动网站才能拥有更好的用户体验？既然 DOM 操作有性能瓶颈，要想突破这个瓶颈就只能抛弃 DOM 换用其他的解决方案了。 FlipBoard原本是一个手机App，他们的 Web 版本 没有使用DOM，而是将整个网站用canvas输出！ 可以用手机打开 flipboard.com 体验一下，我觉得它里面的各种手势操作已经很流畅了，体验基本已经快要接近原生了。 这个方案的出发点是这样的：如果将网页变成了一个个canvas，用户就等于在跟图片互动，这样就绕开了DOM，降低了操作时滞。而且，canvas可以被硬件加速，这样就提高了性能。具体的技术细节，可以参考原文。canvas的转化基于React框架实现，FlipBoard 开发了一个专门的库 React-canvas，已经开源。 3. web 的未来PC 时代，web 在与 原生应用的角逐中占了上风。 到了移动互联网时代，原生应用又凭借良好的用户体验现在又跟 web 平分秋色了。 那么未来又会是怎样呢？如果我们能再多出几种像 flipboard 这种的性能解决方案，相信我们 web 还会在下一个时代，再次打败原生应用独占鳌头。 参考文章： 如何用 fps 衡量 web 页面性能？ 移动web的60fps实现 | Flipboard 更多文章，可以访问: 我的csdn博客","tags":[{"name":"移动web","slug":"移动web","permalink":"http://xuzhengmao.com/tags/移动web/"}]},{"title":"for...in 与 for...of 你千万别混淆","date":"2017-04-19T13:18:43.000Z","path":"2017/04/19/for-in-compare-for-of/","text":"遇到不少人其实是分不太清 for…in 和 for…of 的。大都是用的时候试下，哪个能解决问题还不报错，就选用哪个了。 for…in 循环会遍历一个对象所有的可枚举属性。 for…of 会循环迭代出有序对象（或集合）的每一个属性值。 这是 MDN 上的官方解释。下面，用两个例子说明一切。 遍历的是数组等等，按照刚在开头的解释，这两个不都是用来遍历对象的么？怎么也可以用来遍历数组？ 大哥啊，数组不就是一种对象吗？在 JavaScript 里，万物皆为对象啊 : ) 所以，你可以把数组看成是一种元素有序的对象。 既然如此，先声明一个数组 iterable： 1let iterable = [3, 5, 7]; 使用 for…in 遍历: 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2&#125; 既然数组是一种特殊的对象，那 iterable 的属性就是其下标了。for…in 遍历的是对象属性，那打印出的自然就是 0，1，2 了。 使用 for…of 遍历: 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125; 数组是一种元素有序的对象，iterable 的每个属性其实就是数组的每个元素。for…of 遍历的是对象属性值，所以打印出 3，5，7 了。 遍历的是对象没错，这两者都是可以用来遍历对象的方法。 但 for…of 是为各种有序集合专门定制的，并不适用于所有的对象。 如果对象含有有序集合，它会以这种方式迭代出该集合的每个元素。 那如果不含有有序集合呢？那当然就不灵了，这超越了本文的讨论范围，暂不讨论。 （前方高能，没听过 JavaScript 原型的请绕行） 先使用原型继承的方法，给 Object 对象和 Array 对象拓展两个属性，属性值均为函数。 12Object.prototype.objCustom = function () &#123;&#125;; Array.prototype.arrCustom = function () &#123;&#125;; 接着还是跟上一个例子一样，定义一个 iterable，然后添加一个属性 foo: 12let iterable = [3, 5, 7];iterable.foo = \"hello\"; 这个时候 iterable 变得有点小复杂了。 首先，它声明的就是一个数组，所以它应该包含 arrCustom 属性； 其次，数组本身又是一种对象，那它又应该包含刚给 Object 对象拓展的 objCustom 属性； 再次，它声明时给的是一个数组 [3, 5, 7]，那它肯定包含 3，5，7 这样一个有序集合； 最后 iterable.foo = &quot;hello 又给它增加了一个属性 foo。 那总结一下就是，iterable 包含一个有序集合 3，5，7，然后还包含 arrCustom、 objCustom、foo 三个属性（无序集合） 此时，使用 for…in 遍历 iterable: 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\"&#125; 如果你记住了开篇的一句话 —— for…in 循环会遍历一个对象所有的可枚举属性，那你应该很容易明白打印出来的就是 iterable 所有的属性（其中有序集合是个数组，跟第一个例子一样会打印出数组下标）。 如果使用 for…of 遍历 iterable: 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125; 有了第一个例子做支撑，这里也好理解了。for…of 只能遍历对象中有序集合部分，iterable 中有序的部分就是数组 [3, 5, 7]，那必然只会打印出 3, 5, 7 了。 对比总结 for…in 是循环遍历对象属性。它会遍历一个对象所有的可枚举属性(如果是数组则打印其对应下标)。 for…of 是循环遍历对象属性值。它是为各种有序集合专门定制的，并不适用于所有的对象。它会以这种方式迭代出有序对象每个元素（如果该有序对象是一个数组，则是迭代出它每一个元素）。 我也是每次使用依然每次都要查文档，关键是每次查了下次用的时候还是迷迷糊糊的。所以决定用这两个例子来辅助记忆，希望我下次使用不会再查文档了。呵~ 更多文章，可以访问: 我的csdn博客","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xuzhengmao.com/tags/javascript/"}]},{"title":"JavaScript 的深拷贝和浅拷贝","date":"2017-04-09T04:20:33.000Z","path":"2017/04/09/deep-copy-and-shallow-copy/","text":"在 JavaScript 的变量赋值操作中，对于简单的数据类型（如 Number、String、Boolean 等）可以直接等号复制。但如果是对象或者数组，直接复制会造成新对象或者数组只要一修改，原对象或者数组就会同样跟着被修改。这没毛病也不是 bug，这就是深拷贝与浅拷贝的体现。 什么是深拷贝和浅拷贝？浅拷贝比较容易理解，所以先从浅拷贝开始说起吧！ 浅拷贝 就是将一个对象（或数组）的内存地址『编号』复制给另一个对象（或数组） 深拷贝 增加一个指针，并且申请一个新的内存地址，使这个增加的指针指向这个新的内存，然后将原变量对应内存地址里的值逐个复制过去 深拷贝和浅拷贝怎么实现？数组 eg1. 浅拷贝123456var arr = [\"One\", \"Two\", \"Three\"];console.log(\"原数组的值：\" + arr);var newArr = arr;newArr[1] = \"newTwo\";console.log(\"新数组的值：\" + newArr);console.log(\"浅拷贝后，原数组的值：\" + arr); 运行结果： 因为 arr 浅拷贝赋值给 newArr 的是一个指向 arr 内存地址的引用，所以修改 newArr 的第2个元素的值，会将原数组 arr 的第二个元素值也修改掉了（其实在内存里，两个数组共用一个内存空间）。 eg2. 深拷贝123456var arr = [\"One\", \"Two\", \"Three\"];console.log(\"原数组的值：\" + arr);var newArr = arr.slice(0);newArr[1] = \"newTwo\";console.log(\"新数组的值：\" + newArr);console.log(\"深拷贝后，原数组的值：\" + arr); 运行结果： 严格来讲，该方法不是真正的深拷贝，但是对于我们平常大部分情况还适用（当某个元素是对象，且它含有子方法时不行）。因为深拷贝是给 newArr 申请一个新的内存地址，并使 newArr 的指针指向这个新的内存。然后再把 arr 对应内存的值逐个复制到这个新内存地址。所以这时再修改 newArr 的第2个元素的值，就不会将原数组 arr 的第二个元素值也修改掉了（在内存里，两个数组不再共用一个内存空间了）。 对象 eg1. 浅拷贝12345678910111213var obj = &#123; name: 'xu', age: 24, sex: 'men',&#125;console.log(\"原对象的值：\");console.log(obj);var newObj = obj;newObj.age = 25;console.log(\"新对象的值：\");console.log(newObj);console.log(\"浅拷贝后，原对象的值：\");console.log(obj); 运行结果： 对象的浅拷贝跟数组一样，因为赋值过去的是原对象的引用，所以修改了新对象 newObj 的属性 age 后，原对象属性 age 也被修改了。 eg2. 深拷贝12345678910111213141516var obj = &#123; name: 'xu', age: 24, sex: 'men',&#125;console.log(\"原对象的值：\");console.log(obj);var newObj = &#123;&#125;;for (var i in obj) &#123; newObj[i] = obj[i];&#125;newObj.age = 25;console.log(\"新对象的值：\");console.log(newObj);console.log(\"深拷贝后，原对象的值：\");console.log(obj); 运行结果： 该方法是对象深拷贝，但这是针对一个对象中的所有属性值都是基本数据类型的情况。但是如果一个对象的属性值还是对象这种情况，就需要递归调用浅拷贝。可以如下处理： eg. 对象深拷贝拓展123456789101112131415161718192021222324252627282930313233function deepCopy(obj, copyObj) &#123; var newObj = copyObj || &#123;&#125;; for (var i in obj) &#123; if (typeof obj[i] === 'object') &#123; newObj[i] = (obj[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(obj[i], newObj[i]); &#125; else &#123; newObj[i] = obj[i]; &#125; &#125; return newObj;&#125;var obj = &#123; name: &#123; oldName: 'pan', newName: 'zhengmao' &#125;, age: 24, sex: 'men',&#125;console.log(\"原对象的 name 属性值：\");console.log(obj.name);var secObj = &#123;&#125;;secObj = deepCopy(obj, secObj); // 将 obj 的所有属性都复制到 secObj 中secObj.name = &#123; oldName: 'pan2', newName: 'zhengmao2'&#125;console.log(\"新对象的的 name 属性值：\");console.log(secObj.name);console.log(\"深拷贝后，原对象的 name 属性值：\");console.log(obj.name); 运行结果： 实现原理，其实就是先新建一个空对象，在内存中新开辟一块地址，把被复制对象的所有可枚举的（注意可枚举的对象）属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到所有子代属性都为基本数据类型。 结论数组和对象真正的深拷贝都没有对应现成的api方法可以直接使用，需要我们逐个元素方法递归浅拷贝来自己实现。 但是其他我们常用的伪深拷贝方法，还是有必要了解下，毕竟大多时候这些伪深拷贝就够用了。 数组伪深拷贝： 数组截取：var newArr = arr.slice(0) 数组连接：var newArr = arr.concat([]) 数组转字符串，再转回数组：var newArr = arr.join(&#39;,&#39;).split(&#39;,&#39;) 用可迭代对象创建数组：var newArr = Array.from(arr)这些都只能深拷贝属性，不能深拷贝方法 对象伪深拷贝： 对象拷贝方法：var newObj = Object.assign({}, obj)只能深拷贝对象第一代子成员，后代的成员是浅拷贝 字符串对象互转方法结合：var newObj = JSON.parse( JSON.stringify(obj) )只能深拷贝属性，方法会被遗弃掉 更多文章，可以访问: 我的csdn博客","tags":[]},{"title":"圣杯布局 VS 双飞翼布局","date":"2017-03-30T01:54:50.000Z","path":"2017/03/30/classical-layout-comparison/","text":"作为前端开发者，布局都应该已经写了不少了，但很多时候我们实现布局的思路可能都不一定正确或者不是最合适的。要想自己的布局水平有所提高，两个经典的布局： 圣杯布局 和 双飞翼布局，我个人觉得还是很有必要掌握的。 圣杯布局和双飞翼布局都是为了实现一种非常常见的布局：即两侧定宽，中间自适应的三列布局，特征是中间列要放在文档流前面以优先渲染。 既然都是为了解决同一个问题，那么有哪些不同呢？我们先来稍微回顾一下这两种布局，再加以比较。 圣杯布局圣杯布局的来历是2006年发在a list part上的这篇文章： 点击原文链接 html 部分：12345&lt;div id=\"container\"&gt; &lt;div id=\"main\" class=\"col\"&gt; #main &lt;/div&gt; &lt;div id=\"left\" class=\"col\"&gt; #left &lt;/div&gt; &lt;div id=\"right\" class=\"col\"&gt; #right &lt;/div&gt;&lt;/div&gt; css 部分：12345678910111213141516171819202122232425#container &#123; padding-left: 200px; padding-right: 250px;&#125;.col &#123; position: relative; float: left; height: 300px; &#125;#main &#123; width: 100%; background-color: rgba(255, 0, 0, .5);&#125;#left &#123; width: 200px; margin-left: -100%; left: -200px; background-color: rgba(0, 255, 0, .5);&#125;#right &#123; width: 250px; margin-left: -250px; left: 250px; background-color: rgba(0, 0, 255, .5);&#125; 大致实现思路：三个 col 的容器 #container 一开始先空出左右两个地方，准备待会儿放左列和右列。三个 col 都设置 float: left 和 相对定位，然后左列 margin-left: -100%; 则左列跟中间主列左对齐了。这时左列相对定位加上 left 值是负的左列宽度，就飘到最左边了；右列同理，margin-left 值是负的自身宽度，这时右列跟中间主列右对齐了。右列也是相对定位的，left 值是自身宽度时，右列就飘到最右侧了。 双飞翼布局双飞翼布局的概念始于淘宝UED，据说是玉伯提出的（网上看到的，未求证）。意思是：如果把三列布局比作一只大鸟，可以把中间的主列看成是鸟的身体，左右则是鸟的翅膀。这个布局的实现思路是，先把最重要的身体部分放好，然后再将翅膀移动到适当的地方。 html 部分：12345&lt;div id=\"main-wrapper\" class=\"col\"&gt; &lt;div id=\"main\"&gt; #main &lt;/div&gt;&lt;/div&gt;&lt;div id=\"left\" class=\"col\"&gt; #left &lt;/div&gt;&lt;div id=\"right\" class=\"col\"&gt; #right &lt;/div&gt; css 部分：1234567891011121314151617181920212223.col &#123; float: left; height: 300px; &#125;#main-wrapper &#123; width: 100%;&#125;#main &#123; height: 300px; margin-left: 200px; margin-right: 250px; background-color: rgba(255, 0, 0, .5);&#125;#left &#123; width: 200px; margin-left: -100%; background-color: rgba(0, 255, 0, .5);&#125;#right &#123; width: 250px; margin-left: -250px; background-color: rgba(0, 0, 255, .5);&#125; 大致实现思路：在圣杯布局的 dom 基础上，给 中间列加了个容器，然后在容器里面左右各空出一个地方，准备待会儿放左列和右列。三个 col 都设置 float: left，然后左列 margin-left: -100%， 则左列就飘到最左边了；右列稍有不同，margin-left 值是负的自身宽度，这时右列就飘到最右侧了。 对比圣杯布局 特征：主列先加载，统一浮动，统一相对定位，设置负边距 优点：不需要额外的 dom 节点 缺点：需要清除浮动，需要设置相对定位 双飞翼布局 特征：主列先加载，仅需统一浮动、负边距 优点：兼容性非常好，IE5.5 以上都支持 缺点：需要额外的 dom 节点 其实，实现这种经典的三列布局，还有另外两种思路：一种是圣杯布局的变种 —— 改用绝对定位来实现，一种是使用 flex 布局来实现。有兴趣的可以自己尝试下，这里我也简单的做出对比： 绝对定位 特征：按先后顺序加载，需要设置浮动、绝对定位、负边距 优点：无高度坍塌，没有破坏文档流，不需要清除浮动 缺点：浮动、绝对定位、负边距齐齐上阵，容易混淆 flex 布局 特征：容器 display 指为 flex，主列 flex 值为1，两侧宽度固定 优点：写法简洁，易理解（还可以改写成一个响应式的三列布局，分辨率是移动设备时两侧都出现在主列下边） 缺点：兼容性不好，需要加上各类浏览器前缀 总的来看，网页布局技巧不外乎：浮动、绝对定位 / 相对定位、负边距、flex 布局。能把这几个灵活的搭配用到一起，大部分的布局一般就都能实现了。选用最合适的方法来布局，不仅能帮你节省很多时间，还能提升不少页面的加载性能。 更多文章，可以访问: 我的csdn博客","tags":[{"name":"CSS 布局","slug":"CSS-布局","permalink":"http://xuzhengmao.com/tags/CSS-布局/"}]},{"title":"闲话 git merge 与 git rebase 的区别","date":"2017-03-12T09:35:08.000Z","path":"2017/03/12/merge-compare-rebase/","text":"最近换工作，面试碰到一次笔试考这两个的区别。开始学习git的时候，这两个的区别是有了解过的。但是时间长了加上之前公司应用得少了，所以当时记得很模糊。笔试完就赶紧回家整理了下，希望可以借此加深印象。 merge如果一开始我们的分支情况如下图，有一个主分支 master 及一个开发分支 deve： 假定我们目前处在 master 主分支上，在该项目根目录路径下输入命令： 1$ git merge deve Git 系统会以两个分支的共同祖先 e381a81 为基础，将两个分支的最新提交 8ab7cff 和 696398a 进行三方合并（分支路径没有合并），然后将合并中修改的内容生成一个新的 commit，即下图的 78941cb： rebase假如我们初始的分支情况如下图： 我们还是处在 master 分支上，我们在该项目根目录路径下输入命令： 1$ git rebase deve 这时 Git 系统会将 master 中没有 deve 的部分 bcde65c 和 35b6708 都合并进 master，这个过程是不会修改 deve 分支的。此时两个分支暂时合并成一根线，如下图所示： merge 和 rebase 的区别对比： 对比项 merge rebase 操作过程 将两个分支的修改信息合并 将目标分支中有而当前没有的提交都加进当前分支，但不修改目标分支 分支路径 多条，各自显示，此时交叉了 单条，合在一起显示 历史版本信息 忠实反映各分支实际发生过什么 只反映项目过程中发生过什么 冲突处理 遇见冲突后会直接停止，等待手动解决冲突并重新提交 commit 后，才能再次 merge 遇见冲突后会暂停当前操作，开发者可以选择手动解决冲突，然后 git rebase –continue 继续，或者 –skip 跳过（注意此操作中当前分支的修改会直接覆盖目标分支的冲突部分），亦或者 –abort 直接停止该次 rebase 操作 辅助记忆可以类比同学 a 和同学 b 考试对答案的场景，来区别 merge 和 rebase。 a merge b =&gt; 等同 a 和 b 相互对答案，觉得对方对或者对方做了自己没做的就修改过来。最终和他们各自开始的答案相比，他们的答案都修改了（不考虑开始就答案相同的情况）。 a rebase b =&gt; 等同 a 抄 b 的答案，觉得 b 对或者 b 做了自己没做的就按照他的抄过来。最终只有 a 的答案修改了，b 的答案不会被修改。 参考文档：点击进入 git 官网 更多文章，可以访问: 我的csdn博客","tags":[{"name":"git","slug":"git","permalink":"http://xuzhengmao.com/tags/git/"}]},{"title":"回顾盒子模型之 box-sizing 属性","date":"2017-02-20T02:03:59.000Z","path":"2017/02/20/css-box-model/","text":"盒子模型是CSS中很重要也很常见的概念，它涉及到的无非就是内容(content)、填充(padding)、边框(border)、边界(margin)。但是真要你把这几个的关系说清楚，相信不少人会掉坑。因为很多人没注意到的是，盒子模型其实有两种类型：标准盒模型和IE盒模型。 标准盒模型1box-sizing: content-box; 网上盗了张图： 由上图可以看出，标准盒模型的 width 组成：content（不包含 padding 和 border） 比如：你给一个div的宽度设为200px，那这个div实际的宽度其实是200px再加上padding和border的值（和是大于等于200px的）。 IE盒模型1box-sizing: border-box; 网上又盗了张图： 由上图可以看出，IE盒模型的 width 组成：content + 2 * padding + 2 * border 比如：你给一个div的宽度设为200px，那这个div内容的宽度其实只有200px减去 padding 和 border 的值。它实际宽度是小于或等于200px的。 对比总结 box-sizing: content-box | border-box | inherit 他们的主要区别其实就是 width/height 包不包含 border 和 padding box-sizing 默认值是 content-box，即 默认是标准盒子模型 更多文章，可以访问: 我的csdn博客","tags":[{"name":"css 盒子模型","slug":"css-盒子模型","permalink":"http://xuzhengmao.com/tags/css-盒子模型/"}]},{"title":"厨子和程序员","date":"2016-09-19T03:47:03.000Z","path":"2016/09/19/cook-and-programmer/","text":"在程序员们的圈子里，曾经流传过这样一个段子： 1、你去饭店坐下来 顾客: hi，给我来份宫保鸡丁！服务员: 好嘞！ 2、厨子做到一半 顾客: 服务员，菜里不要放肉服务员: 不放肉怎么做啊？顾客: 不放肉就行了，其它按正常程序做，不就行了，难吗？服务员: 好的您稍等 3、厨房 厨子: 你大爷，我肉都回锅了服务员: 顾客非要要求的嘛，你把肉挑出来不就行了吗厨子: 行你大爷 然而厨子还是一点一点挑出来了。 4、餐厅 顾客: 服务员，菜里能给我加点腐竹吗？服务员: 行，这个应该简单 5、厨房 厨子: 擦，不知道腐竹得提前泡水？炒到一半才说？跟他说，想吃腐竹就多等半天服务员: 啊，你怎么不早说？厨子: 早说你M！ 我怎么知道他要往宫保鸡丁里放腐竹 然而厨子还是去泡腐竹了 6、餐厅 顾客: 服务员，还是把肉加回去吧服务员: 您不是刚说不要肉吗顾客: 现在又想要了服务员: 好的您稍等 7、厨房 厨子: 日你啊，菜都炒过火了你让我放肉？ 还好肉我没扔服务员: 顾客提的要求你日我干嘛？厨子: 你就不能拒绝他啊？啊？？服务员: 人家是顾客嘛 8、餐厅 顾客: 服务员！服务员！服务员: 来了来了，您好？顾客: 怎么这么半天啊？服务员: 稍等，我给您催催啊 9、厨房 厨子: 催你M催，腐竹没泡好，我还得重新放油，他要想吃老的也行，没法保质保量 10、餐厅 服务员: 抱歉，加腐竹的话得多等半天，您别着急哈顾客: 我靠要等那么久？我现在就要吃，你们能快点吗？服务员: 争取争取 … 您稍等 11、厨房 厨子: 我日他仙人板板，中途改需求又想按期交付，逗我玩呢？服务员: 那我问问，要不让他们换个菜？厨子: 再换我就死了 12、餐厅 顾客: 服务员，这样吧，腐竹不要了，换成蒜毫能快点吗？对了，顺便加点番茄酱 13、厨房 厨子: 我日了狗啊，你TM不知道蒜毫也得焯水啊？还有你让我怎么往热菜里放番茄酱啊？？服务员: 焯水也比等腐竹强吧，番茄酱往里一倒不就行了吗？很难吗？厨子: 艹。腐竹我还得接着泡，万一这孙子一会又想要了呢。 14、餐厅 顾客: 服务员，菜里加茄丁了没有？我去其它饭店吃可都是有茄丁的服务员: 好好好，您稍等您稍等 15、厨房 厨子: 我去他大爷的，他吃的是斯里兰卡三流技校炒的宫保鸡丁吗？宫保鸡丁里放茄丁？？服务员: 茄丁抄好了扔里边不就行了吗？厨子: 那TM还能叫菜吗？哪个系的？服务员: 顾客要，你就给炒了吧。厨子: MB你顺道问问他腐竹还要不要，我这盆腐竹还占着地方呢不要我就扔了 16、餐厅 顾客: 服务员，还要多久能好啊服务员: 很快，很快 …顾客: 那送杯西瓜汁吧，等这么久服务员: —— 好顾客: 再等10分钟，还不好我就走了，反正还没给钱服务员: 很快，很快 … 17、十分钟后 顾客: 咦，我上次吃的不是这个味啊？服务员: 。。。。。。厨子: #￥%&amp;##&amp; …… %# 这是一个程序员运用厨子的故事来极致嘲讽自身行业的段子，相信有着亲身丰富体验的老司机一看就懂。虽然故事未必为真，但从工作分工方面来看，程序员和厨子真的很类似。 先说厨子吧。只有两三个人厨师的小饭店，从定菜单、采办、配菜、烧炒煮蒸拌 …… 每个人都要管一摊子事；但是有几十号厨师班子的大饭店，什么主厨、大厨、二厨、配菜的都分得很清楚。熟食、面点、凉菜、热菜等等，每道菜也都有专门负责的人。 程序员跟厨子很像。小公司的程序员，从项目的环境配置，到功能开发，再到部署上线，统统都是自己来。再节约成本一点的创业公司，甚至能让你动不动和需求分析、产品设计这些也沾点边；但是在大公司，基本很少有人能从前到后一把揽下所有的事情（一是项目太大你做不到，二是公司也不需要你做那些你分外的且不擅长的事）。项目配置和环境搭建有专门的人做，发布部署也有人负责，就连实际的开发，也是分门别类，前端、后台、移动端、数据库、安全等等等。而你只需要做其中的一颗螺丝钉，就好。 小饭店的厨子，什么菜都会做一些，可以很快就能做出一整桌一整桌的菜。但是在大饭店一般只专门负责一两种或面点或热食的师傅，能做出一两道一手绝活的菜，是肯定的。但是你让他失去同伴们的配合，离开厨师团队出去自立门户，可能又会有抓瞎的可能。 所以，综合程序员和厨子的对比得出的结论是：程序员在小公司工作的好处是，项目实战经验非常丰富，成长的机会很多，因为你不做就没人做了。但是在大公司工作，能开阔你的眼界。因为你有机会接触到大项目，你有机会见到最高档次的『宴席』前前后后是怎么一个流程。怎么跟那么多的同事合作，怎么跟各个部门的同事协调，怎么做到尽善尽美达到极致。 作为程序员而言，我们两种经历都有自然是最好的。既见过满汉全席这种大餐是怎么做的，也能个人单刀赴会，一个人亲自动手负责项目的前前后后。这样才会让我们的知识既做到有深度，又能有广度。 这样的你，上天入地，天下任你行，走哪儿哪儿都不怕！ 更多文章，可以访问: 我的csdn博客","tags":[{"name":"互联网的那些事","slug":"互联网的那些事","permalink":"http://xuzhengmao.com/tags/互联网的那些事/"}]}]