[{"title":"git stash 和 git stash pop","date":"2017-06-17T03:54:18.000Z","path":"2017/06/17/git-stash/","text":"git stash 可以用来暂存当前正在进行的工作。 比如，你想 pull 最新代码，又不想加新 commit 的时候。 又或者另外一种情况，为了 fix 一个紧急的 bug，先 git stash, 使返回到自己上一个 commit，改完 bug 之后再 git stash pop，继续原来的工作。 基础命令： 123git stash// do some workgit stash pop 进阶： git stash save &quot;work in progress for foo feature&quot; 当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，你可以输入： git stash list 将当前的 git 栈信息全都打印出来，你只需要将找到对应的版本号，例如使用 git stash apply stash@{1} 就可以将你指定版本号为 stash@{1} 的工作取出来。当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。 git stash apply 和 git stash pop 区别两者都可以把 git 栈里面的内容取出来，但 git stash apply 恢复后，stash 内容并不会被删除，除非你再用 git stash drop 来删除； 而用 git stash pop，它在恢复的同时把 stash 内容也删了。 相关命令12345678git stash # save uncommitted changesgit stash list # list stashed changes in this gitgit show stash@&#123;0&#125; # see the last stash git stash pop # apply last stash and remove it from the listgit stash apply # apply last stashgit stash drop # remove it from the listgit stash clear # remove the whole git stash listgit stash --help # for more info 参考资料： 廖雪峰 git 教程 - Bug分支 git 官方文档 更多文章，可以访问: 我的csdn博客","tags":[{"name":"git","slug":"git","permalink":"http://xuzhengmao.com/tags/git/"}]},{"title":"如何让你的移动网站拥有原生应用般的体验？","date":"2017-05-05T11:33:19.000Z","path":"2017/05/05/make-mobile-web-look-likes-app/","text":"众所周知移动网站在开发、迭代版本方面，比原生APP更具有优势，但是在用户体验方面却逊色很多。用户体验差表现在哪些方面呢？主要是 互动（interaction）和动画（animation）这两方面。 那么为什么我们不能把移动web的用户体验做得更好呢？这还得从web的性能瓶颈说起 … 1. 移动网站为什么不能拥有原生般的体验？阮一峰老师在他的 《也许，DOM 不是答案》一文中分析了移动 web 性能瓶颈的几个原因： Web基于DOM，而DOM加载很慢 DOM拖慢JavaScript，因为所有的 DOM 操作都是同步的，一个操作没完，后面的操作都需要等待 网页是单线程的 网页没有硬件加速，网页由CPU处理，没用GPU图形加速。 这些原因对于 PC 端 网站没有太大影响。但是手机硬件资源有限，用户互动又相对频繁，于是跟原生应用相比，自然就出现了明显的不足。 2. 怎样做，移动网站才能拥有更好的用户体验？既然 DOM 操作有性能瓶颈，要想突破这个瓶颈就只能抛弃 DOM 换用其他的解决方案了。 FlipBoard原本是一个手机App，他们的 Web 版本 没有使用DOM，而是将整个网站用canvas输出！ 可以用手机打开 flipboard.com 体验一下，我觉得它里面的各种手势操作已经很流畅了，体验基本已经快要接近原生了。 这个方案的出发点是这样的：如果将网页变成了一个个canvas，用户就等于在跟图片互动，这样就绕开了DOM，降低了操作时滞。而且，canvas可以被硬件加速，这样就提高了性能。具体的技术细节，可以参考原文。canvas的转化基于React框架实现，FlipBoard 开发了一个专门的库 React-canvas，已经开源。 3. web 的未来PC 时代，web 在与 原生应用的角逐中占了上风。 到了移动互联网时代，原生应用又凭借良好的用户体验现在又跟 web 平分秋色了。 那么未来又会是怎样呢？如果我们能再多出几种像 flipboard 这种的性能解决方案，相信我们 web 还会在下一个时代，再次打败原生应用独占鳌头。 参考文章： 如何用 fps 衡量 web 页面性能？ 移动web的60fps实现 | Flipboard 更多文章，可以访问: 我的csdn博客","tags":[{"name":"移动web","slug":"移动web","permalink":"http://xuzhengmao.com/tags/移动web/"}]},{"title":"for...in 与 for...of 你千万别混淆","date":"2017-04-19T13:18:43.000Z","path":"2017/04/19/for-in-compare-for-of/","text":"遇到不少人其实是分不太清 for…in 和 for…of 的。大都是用的时候试下，哪个能解决问题还不报错，就选用哪个了。 for…in 循环会遍历一个对象所有的可枚举属性。 for…of 会循环迭代出有序对象（或集合）的每一个属性值。 这是 MDN 上的官方解释。下面，用两个例子说明一切。 遍历的是数组等等，按照刚在开头的解释，这两个不都是用来遍历对象的么？怎么也可以用来遍历数组？ 大哥啊，数组不就是一种对象吗？在 JavaScript 里，万物皆为对象啊 : ) 所以，你可以把数组看成是一种元素有序的对象。 既然如此，先声明一个数组 iterable： 1let iterable = [3, 5, 7]; 使用 for…in 遍历: 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2&#125; 既然数组是一种特殊的对象，那 iterable 的属性就是其下标了。for…in 遍历的是对象属性，那打印出的自然就是 0，1，2 了。 使用 for…of 遍历: 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125; 数组是一种元素有序的对象，iterable 的每个属性其实就是数组的每个元素。for…of 遍历的是对象属性值，所以打印出 3，5，7 了。 遍历的是对象没错，这两者都是可以用来遍历对象的方法。 但 for…of 是为各种有序集合专门定制的，并不适用于所有的对象。 如果对象含有有序集合，它会以这种方式迭代出该集合的每个元素。 那如果不含有有序集合呢？那当然就不灵了，这超越了本文的讨论范围，暂不讨论。 （前方高能，没听过 JavaScript 原型的请绕行） 先使用原型继承的方法，给 Object 对象和 Array 对象拓展两个属性，属性值均为函数。 12Object.prototype.objCustom = function () &#123;&#125;; Array.prototype.arrCustom = function () &#123;&#125;; 接着还是跟上一个例子一样，定义一个 iterable，然后添加一个属性 foo: 12let iterable = [3, 5, 7];iterable.foo = \"hello\"; 这个时候 iterable 变得有点小复杂了。 首先，它声明的就是一个数组，所以它应该包含 arrCustom 属性； 其次，数组本身又是一种对象，那它又应该包含刚给 Object 对象拓展的 objCustom 属性； 再次，它声明时给的是一个数组 [3, 5, 7]，那它肯定包含 3，5，7 这样一个有序集合； 最后 iterable.foo = &quot;hello 又给它增加了一个属性 foo。 那总结一下就是，iterable 包含一个有序集合 3，5，7，然后还包含 arrCustom、 objCustom、foo 三个属性（无序集合） 此时，使用 for…in 遍历 iterable: 123for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\"&#125; 如果你记住了开篇的一句话 —— for…in 循环会遍历一个对象所有的可枚举属性，那你应该很容易明白打印出来的就是 iterable 所有的属性（其中有序集合是个数组，跟第一个例子一样会打印出数组下标）。 如果使用 for…of 遍历 iterable: 123for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125; 有了第一个例子做支撑，这里也好理解了。for…of 只能遍历对象中有序集合部分，iterable 中有序的部分就是数组 [3, 5, 7]，那必然只会打印出 3, 5, 7 了。 对比总结 for…in 是循环遍历对象属性。它会遍历一个对象所有的可枚举属性(如果是数组则打印其对应下标)。 for…of 是循环遍历对象属性值。它是为各种有序集合专门定制的，并不适用于所有的对象。它会以这种方式迭代出有序对象每个元素（如果该有序对象是一个数组，则是迭代出它每一个元素）。 我也是每次使用依然每次都要查文档，关键是每次查了下次用的时候还是迷迷糊糊的。所以决定用这两个例子来辅助记忆，希望我下次使用不会再查文档了。呵~ 更多文章，可以访问: 我的csdn博客","tags":[{"name":"javascript","slug":"javascript","permalink":"http://xuzhengmao.com/tags/javascript/"}]},{"title":"JavaScript 的深拷贝和浅拷贝","date":"2017-04-09T04:20:33.000Z","path":"2017/04/09/deep-copy-and-shallow-copy/","text":"在 JavaScript 的变量赋值操作中，如果一个变量值是简单类型，直接复制没有问题。但如果是对象或者数组，直接复制后的新对象或者数组只要一修改，原对象或者数组就会同样跟着被修改。如果你不了解深拷贝和浅拷贝，你可能就会觉得这是 bug，不可理解。但是看完本文你就能理解了。 什么是深拷贝和浅拷贝？浅拷贝比较容易理解，所以先从浅拷贝开始说起吧！ 浅拷贝 就是将一个对象（或数组）的内存地址『编号』复制给另一个对象（或数组） 深拷贝 增加一个指针，并且申请一个新的内存地址，使这个增加的指针指向这个新的内存，然后将原变量对应内存地址里的值逐个复制过去 深拷贝和浅拷贝怎么实现？数组 eg1. 浅拷贝123456var arr = [\"One\", \"Two\", \"Three\"];console.log(\"原数组的值：\" + arr);var newArr = arr;newArr[1] = \"newTwo\";console.log(\"新数组的值：\" + newArr);console.log(\"浅拷贝后，原数组的值：\" + arr); 运行结果： 因为 arr 浅拷贝赋值给 newArr 的是一个指向 arr 内存地址的引用，所以修改 newArr 的第2个元素的值，会将原数组 arr 的第二个元素值也修改掉了（其实在内存里，两个数组共用一个内存空间）。 eg2. 深拷贝123456var arr = [\"One\", \"Two\", \"Three\"];console.log(\"原数组的值：\" + arr);var newArr = arr.slice(0);newArr[1] = \"newTwo\";console.log(\"新数组的值：\" + newArr);console.log(\"深拷贝后，原数组的值：\" + arr); 运行结果： 因为深拷贝是给 newArr 申请一个新的内存地址，并使 newArr 的指针指向这个新的内存。然后再把 arr 对应内存的值逐个复制到这个新内存地址。所以这时再修改 newArr 的第2个元素的值，就不会将原数组 arr 的第二个元素值也修改掉了（在内存里，两个数组不再共用一个内存空间了）。 对象 eg1. 浅拷贝12345678910111213var obj = &#123; name: 'xu', age: 24, sex: 'men',&#125;console.log(\"原对象的值：\");console.log(obj);var newObj = obj;newObj.age = 25;console.log(\"新对象的值：\");console.log(newObj);console.log(\"浅拷贝后，原对象的值：\");console.log(obj); 运行结果： 对象的浅拷贝跟数组一样，因为赋值过去的是原对象的引用，所以修改了新对象 newObj 的属性 age 后，原对象属性 age 也被修改了。 eg2. 深拷贝12345678910111213141516var obj = &#123; name: 'xu', age: 24, sex: 'men',&#125;console.log(\"原对象的值：\");console.log(obj);var newObj = &#123;&#125;;for (var i in obj) &#123; newObj[i] = obj[i];&#125;newObj.age = 25;console.log(\"新对象的值：\");console.log(newObj);console.log(\"深拷贝后，原对象的值：\");console.log(obj); 运行结果： 这是针对一个对象中的所有属性值都是基本数据类型的情况。但是如果一个对象的属性值还是对象这种情况，就需要递归调用浅拷贝。可以如下处理： eg. 对象深拷贝拓展123456789101112131415161718192021222324252627282930313233function deepCopy(obj, copyObj) &#123; var newObj = copyObj || &#123;&#125;; for (var i in obj) &#123; if (typeof obj[i] === 'object') &#123; newObj[i] = (obj[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(obj[i], newObj[i]); &#125; else &#123; newObj[i] = obj[i]; &#125; &#125; return newObj;&#125;var obj = &#123; name: &#123; oldName: 'pan', newName: 'zhengmao' &#125;, age: 24, sex: 'men',&#125;console.log(\"原对象的 name 属性值：\");console.log(obj.name);var secObj = &#123;&#125;;secObj = deepCopy(obj, secObj); // 将 obj 的所有属性都复制到 secObj 中secObj.name = &#123; oldName: 'pan2', newName: 'zhengmao2'&#125;console.log(\"新对象的的 name 属性值：\");console.log(secObj.name);console.log(\"深拷贝后，原对象的 name 属性值：\");console.log(obj.name); 运行结果： 实现原理，其实就是先新建一个空对象，在内存中新开辟一块地址，把被复制对象的所有可枚举的（注意可枚举的对象）属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到所有子代属性都为基本数据类型。 结论数组深拷贝： 数组截取：var newArr = arr.slice(0) 数组连接：var newArr = arr.concat() 数组转字符串，再转回数组：var newArr = arr.join(&#39;,&#39;).split(&#39;,&#39;) 无脑方法：for 循环逐个元素拷贝 对象深拷贝： 对象拷贝方法：var newObj = Object.assign({}, obj) 字符串对象互转方法结合：var newObj = JSON.parse( JSON.stringify(obj) ) 无脑方法：for 循环逐个属性拷贝 对于简单的数据类型（如 Number、String、Boolean 等），JavaScript 变量赋值即是值复制（深拷贝）。但是对象或者数组，直接赋值其实复制的只是内存地址（浅拷贝）。这样错误的操作会让父对象或父数组随时存在被篡改的可能。所以数组和对象拷贝时，我们可以按照以上方法进行深拷贝。 更多文章，可以访问: 我的csdn博客","tags":[]},{"title":"圣杯布局 VS 双飞翼布局","date":"2017-03-30T01:54:50.000Z","path":"2017/03/30/classical-layout-comparison/","text":"作为前端开发者，布局都应该已经写了不少了，但很多时候我们实现布局的思路可能都不一定正确或者不是最合适的。要想自己的布局水平有所提高，两个经典的布局： 圣杯布局 和 双飞翼布局，我个人觉得还是很有必要掌握的。 圣杯布局和双飞翼布局都是为了实现一种非常常见的布局：即两侧定宽，中间自适应的三列布局，特征是中间列要放在文档流前面以优先渲染。 既然都是为了解决同一个问题，那么有哪些不同呢？我们先来稍微回顾一下这两种布局，再加以比较。 圣杯布局圣杯布局的来历是2006年发在a list part上的这篇文章： 点击原文链接 html 部分：12345&lt;div id=\"container\"&gt; &lt;div id=\"main\" class=\"col\"&gt; #main &lt;/div&gt; &lt;div id=\"left\" class=\"col\"&gt; #left &lt;/div&gt; &lt;div id=\"right\" class=\"col\"&gt; #right &lt;/div&gt;&lt;/div&gt; css 部分：12345678910111213141516171819202122232425#container &#123; padding-left: 200px; padding-right: 250px;&#125;.col &#123; position: relative; float: left; height: 300px; &#125;#main &#123; width: 100%; background-color: rgba(255, 0, 0, .5);&#125;#left &#123; width: 200px; margin-left: -100%; left: -200px; background-color: rgba(0, 255, 0, .5);&#125;#right &#123; width: 250px; margin-left: -250px; left: 250px; background-color: rgba(0, 0, 255, .5);&#125; 大致实现思路：三个 col 的容器 #container 一开始先空出左右两个地方，准备待会儿放左列和右列。三个 col 都设置 float: left 和 相对定位，然后左列 margin-left: -100%; 则左列跟中间主列左对齐了。这时左列相对定位加上 left 值是负的左列宽度，就飘到最左边了；右列同理，margin-left 值是负的自身宽度，这时右列跟中间主列右对齐了。右列也是相对定位的，left 值是自身宽度时，右列就飘到最右侧了。 双飞翼布局双飞翼布局的概念始于淘宝UED，据说是玉伯提出的（网上看到的，未求证）。意思是：如果把三列布局比作一只大鸟，可以把中间的主列看成是鸟的身体，左右则是鸟的翅膀。这个布局的实现思路是，先把最重要的身体部分放好，然后再将翅膀移动到适当的地方。 html 部分：12345&lt;div id=\"main-wrapper\" class=\"col\"&gt; &lt;div id=\"main\"&gt; #main &lt;/div&gt;&lt;/div&gt;&lt;div id=\"left\" class=\"col\"&gt; #left &lt;/div&gt;&lt;div id=\"right\" class=\"col\"&gt; #right &lt;/div&gt; css 部分：1234567891011121314151617181920212223.col &#123; float: left; height: 300px; &#125;#main-wrapper &#123; width: 100%;&#125;#main &#123; height: 300px; margin-left: 200px; margin-right: 250px; background-color: rgba(255, 0, 0, .5);&#125;#left &#123; width: 200px; margin-left: -100%; background-color: rgba(0, 255, 0, .5);&#125;#right &#123; width: 250px; margin-left: -250px; background-color: rgba(0, 0, 255, .5);&#125; 大致实现思路：在圣杯布局的 dom 基础上，给 中间列加了个容器，然后在容器里面左右各空出一个地方，准备待会儿放左列和右列。三个 col 都设置 float: left，然后左列 margin-left: -100%， 则左列就飘到最左边了；右列稍有不同，margin-left 值是负的自身宽度，这时右列就飘到最右侧了。 对比圣杯布局 特征：主列先加载，统一浮动，统一相对定位，设置负边距 优点：不需要额外的 dom 节点 缺点：需要清除浮动，需要设置相对定位 双飞翼布局 特征：主列先加载，仅需统一浮动、负边距 优点：兼容性非常好，IE5.5 以上都支持 缺点：需要额外的 dom 节点 其实，实现这种经典的三列布局，还有另外两种思路：一种是圣杯布局的变种 —— 改用绝对定位来实现，一种是使用 flex 布局来实现。有兴趣的可以自己尝试下，这里我也简单的做出对比： 绝对定位 特征：按先后顺序加载，需要设置浮动、绝对定位、负边距 优点：无高度坍塌，没有破坏文档流，不需要清除浮动 缺点：浮动、绝对定位、负边距齐齐上阵，容易混淆 flex 布局 特征：容器 display 指为 flex，主列 flex 值为1，两侧宽度固定 优点：写法简洁，易理解（还可以改写成一个响应式的三列布局，分辨率是移动设备时两侧都出现在主列下边） 缺点：兼容性不好，需要加上各类浏览器前缀 总的来看，网页布局技巧不外乎：浮动、绝对定位 / 相对定位、负边距、flex 布局。能把这几个灵活的搭配用到一起，大部分的布局一般就都能实现了。选用最合适的方法来布局，不仅能帮你节省很多时间，还能提升不少页面的加载性能。 更多文章，可以访问: 我的csdn博客","tags":[{"name":"CSS 布局","slug":"CSS-布局","permalink":"http://xuzhengmao.com/tags/CSS-布局/"}]},{"title":"闲话 git merge 与 git rebase 的区别","date":"2017-03-12T09:35:08.000Z","path":"2017/03/12/merge-compare-rebase/","text":"最近换工作，面试碰到一次笔试考这两个的区别。开始学习git的时候，这两个的区别是有了解过的。但是时间长了加上之前公司应用得少了，所以当时记得很模糊。笔试完就赶紧回家整理了下，希望可以借此加深印象。 merge如果一开始我们的分支情况如下图，有一个主分支 master 及一个开发分支 deve： 假定我们目前处在 master 主分支上，在该项目根目录路径下输入命令： 1$ git merge deve Git 系统会以两个分支的共同祖先 e381a81 为基础，将两个分支的最新提交 8ab7cff 和 696398a 进行三方合并（分支路径没有合并），然后将合并中修改的内容生成一个新的 commit，即下图的 78941cb： rebase假如我们初始的分支情况如下图： 我们还是处在 master 分支上，我们在该项目根目录路径下输入命令： 1$ git rebase deve 这时 Git 系统会将 master 中没有 deve 的部分 bcde65c 和 35b6708 都合并进 master，这个过程是不会修改 deve 分支的。此时两个分支暂时合并成一根线，如下图所示： merge 和 rebase 的区别对比： 对比项 merge rebase 操作过程 将两个分支的修改信息合并 将目标分支中有而当前没有的提交都加进当前分支，但不修改目标分支 分支路径 多条，各自显示，此时交叉了 单条，合在一起显示 历史版本信息 忠实反映各分支实际发生过什么 只反映项目过程中发生过什么 冲突处理 遇见冲突后会直接停止，等待手动解决冲突并重新提交 commit 后，才能再次 merge 遇见冲突后会暂停当前操作，开发者可以选择手动解决冲突，然后 git rebase –continue 继续，或者 –skip 跳过（注意此操作中当前分支的修改会直接覆盖目标分支的冲突部分），亦或者 –abort 直接停止该次 rebase 操作 辅助记忆可以类比同学 a 和同学 b 考试对答案的场景，来区别 merge 和 rebase。 a merge b =&gt; 等同 a 和 b 相互对答案，觉得对方对或者对方做了自己没做的就修改过来。最终和他们各自开始的答案相比，他们的答案都修改了（不考虑开始就答案相同的情况）。 a rebase b =&gt; 等同 a 抄 b 的答案，觉得 b 对或者 b 做了自己没做的就按照他的抄过来。最终只有 a 的答案修改了，b 的答案不会被修改。 参考文档：点击进入 git 官网 更多文章，可以访问: 我的csdn博客","tags":[{"name":"git","slug":"git","permalink":"http://xuzhengmao.com/tags/git/"}]},{"title":"回顾盒子模型之 box-size 属性","date":"2017-02-20T02:03:59.000Z","path":"2017/02/20/css-box-model/","text":"盒子模型是CSS中很重要也很常见的概念，它涉及到的无非就是内容(content)、填充(padding)、边框(border)、边界(margin)。但是真要你把这几个的关系说清楚，相信不少人会掉坑。因为很多人没注意到的是，盒子模型其实有两种类型：标准盒模型和IE盒模型。 标准盒模型1box-sizing: content-box; 网上盗了张图： 由上图可以看出，标准盒模型的 width 组成：content（不包含 padding 和 border） 比如：你给一个div的宽度设为200px，那这个div实际的宽度其实是200px再加上padding和border的值（和是大于等于200px的）。 IE盒模型1box-sizing: border-box; 网上又盗了张图： 由上图可以看出，IE盒模型的 width 组成：content + 2 * padding + 2 * border 比如：你给一个div的宽度设为200px，那这个div内容的宽度其实只有200px减去 padding 和 border 的值。它实际宽度是小于或等于200px的。 对比总结 box-sizing: content-box | border-box | inherit 他们的主要区别其实就是 width 包不包含 border 和 padding box-sizing 默认值是 content-box，即默认是标准盒子模型 更多文章，可以访问: 我的csdn博客","tags":[{"name":"css 盒子模型","slug":"css-盒子模型","permalink":"http://xuzhengmao.com/tags/css-盒子模型/"}]},{"title":"厨子和程序员","date":"2016-09-19T03:47:03.000Z","path":"2016/09/19/cook-and-programmer/","text":"在程序员们的圈子里，曾经流传过这样一个段子： 1、你去饭店坐下来 顾客: hi，给我来份宫保鸡丁！服务员: 好嘞！ 2、厨子做到一半 顾客: 服务员，菜里不要放肉服务员: 不放肉怎么做啊？顾客: 不放肉就行了，其它按正常程序做，不就行了，难吗？服务员: 好的您稍等 3、厨房 厨子: 你大爷，我肉都回锅了服务员: 顾客非要要求的嘛，你把肉挑出来不就行了吗厨子: 行你大爷 然而厨子还是一点一点挑出来了。 4、餐厅 顾客: 服务员，菜里能给我加点腐竹吗？服务员: 行，这个应该简单 5、厨房 厨子: 擦，不知道腐竹得提前泡水？炒到一半才说？跟他说，想吃腐竹就多等半天服务员: 啊，你怎么不早说？厨子: 早说你M！ 我怎么知道他要往宫保鸡丁里放腐竹 然而厨子还是去泡腐竹了 6、餐厅 顾客: 服务员，还是把肉加回去吧服务员: 您不是刚说不要肉吗顾客: 现在又想要了服务员: 好的您稍等 7、厨房 厨子: 日你啊，菜都炒过火了你让我放肉？ 还好肉我没扔服务员: 顾客提的要求你日我干嘛？厨子: 你就不能拒绝他啊？啊？？服务员: 人家是顾客嘛 8、餐厅 顾客: 服务员！服务员！服务员: 来了来了，您好？顾客: 怎么这么半天啊？服务员: 稍等，我给您催催啊 9、厨房 厨子: 催你M催，腐竹没泡好，我还得重新放油，他要想吃老的也行，没法保质保量 10、餐厅 服务员: 抱歉，加腐竹的话得多等半天，您别着急哈顾客: 我靠要等那么久？我现在就要吃，你们能快点吗？服务员: 争取争取 … 您稍等 11、厨房 厨子: 我日他仙人板板，中途改需求又想按期交付，逗我玩呢？服务员: 那我问问，要不让他们换个菜？厨子: 再换我就死了 12、餐厅 顾客: 服务员，这样吧，腐竹不要了，换成蒜毫能快点吗？对了，顺便加点番茄酱 13、厨房 厨子: 我日了狗啊，你TM不知道蒜毫也得焯水啊？还有你让我怎么往热菜里放番茄酱啊？？服务员: 焯水也比等腐竹强吧，番茄酱往里一倒不就行了吗？很难吗？厨子: 艹。腐竹我还得接着泡，万一这孙子一会又想要了呢。 14、餐厅 顾客: 服务员，菜里加茄丁了没有？我去其它饭店吃可都是有茄丁的服务员: 好好好，您稍等您稍等 15、厨房 厨子: 我去他大爷的，他吃的是斯里兰卡三流技校炒的宫保鸡丁吗？宫保鸡丁里放茄丁？？服务员: 茄丁抄好了扔里边不就行了吗？厨子: 那TM还能叫菜吗？哪个系的？服务员: 顾客要，你就给炒了吧。厨子: MB你顺道问问他腐竹还要不要，我这盆腐竹还占着地方呢不要我就扔了 16、餐厅 顾客: 服务员，还要多久能好啊服务员: 很快，很快 …顾客: 那送杯西瓜汁吧，等这么久服务员: —— 好顾客: 再等10分钟，还不好我就走了，反正还没给钱服务员: 很快，很快 … 17、十分钟后 顾客: 咦，我上次吃的不是这个味啊？服务员: 。。。。。。厨子: #￥%&amp;##&amp; …… %# 这是一个程序员运用厨子的故事来极致嘲讽自身行业的段子，相信有着亲身丰富体验的老司机一看就懂。虽然故事未必为真，但从工作分工方面来看，程序员和厨子真的很类似。 先说厨子吧。只有两三个人厨师的小饭店，从定菜单、采办、配菜、烧炒煮蒸拌 …… 每个人都要管一摊子事；但是有几十号厨师班子的大饭店，什么主厨、大厨、二厨、配菜的都分得很清楚。熟食、面点、凉菜、热菜等等，每道菜也都有专门负责的人。 程序员跟厨子很像。小公司的程序员，从项目的环境配置，到功能开发，再到部署上线，统统都是自己来。再节约成本一点的创业公司，甚至能让你动不动和需求分析、产品设计这些也沾点边；但是在大公司，基本很少有人能从前到后一把揽下所有的事情（一是项目太大你做不到，二是公司也不需要你做那些你分外的且不擅长的事）。项目配置和环境搭建有专门的人做，发布部署也有人负责，就连实际的开发，也是分门别类，前端、后台、移动端、数据库、安全等等等。而你只需要做其中的一颗螺丝钉，就好。 小饭店的厨子，什么菜都会做一些，可以很快就能做出一整桌一整桌的菜。但是在大饭店一般只专门负责一两种或面点或热食的师傅，能做出一两道一手绝活的菜，是肯定的。但是你让他失去同伴们的配合，离开厨师团队出去自立门户，可能又会有抓瞎的可能。 所以，综合程序员和厨子的对比得出的结论是：程序员在小公司工作的好处是，项目实战经验非常丰富，成长的机会很多，因为你不做就没人做了。但是在大公司工作，能开阔你的眼界。因为你有机会接触到大项目，你有机会见到最高档次的『宴席』前前后后是怎么一个流程。怎么跟那么多的同事合作，怎么跟各个部门的同事协调，怎么做到尽善尽美达到极致。 作为程序员而言，我们两种经历都有自然是最好的。既见过满汉全席这种大餐是怎么做的，也能个人单刀赴会，一个人亲自动手负责项目的前前后后。这样才会让我们的知识既做到有深度，又能有广度。 这样的你，上天入地，天下任你行，走哪儿哪儿都不怕！ 更多文章，可以访问: 我的csdn博客","tags":[{"name":"互联网的那些事","slug":"互联网的那些事","permalink":"http://xuzhengmao.com/tags/互联网的那些事/"}]}]