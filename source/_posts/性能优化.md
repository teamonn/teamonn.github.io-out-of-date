---
title: 域名收敛和域名发散，及前端性能优化
date: 2018-04-02 12:10:39
tags: 性能优化
---

**域名发散** 和 **域名收敛** 是两种策略完全相反的性能优化手段。一般我们按照不同的应用场景，来使用对应的优化手段。

<!--more--> 

### 什么是域名发散？

> 从表现上来看，就是**在http 静态资源存储中采用多个子域名**。通俗讲，就是将网站的静态资源分布在几个不同域。

本质目的是，为了突破浏览器的最大并发数（如下图），其实就是突破浏览器允许同一个域名同时下载的资源数的最大上限（下图中chrome32允许你对同一个域名，能同时下载的资源数是6个）。如果你把资源分为3个子域名存储，那你在chrome32中就可以同时加载18个资源了，这是前端优化的一种手段。

![各主流浏览器最大并发数对比](https://camo.githubusercontent.com/e8881588de4903a30904e30de1fc6548ff906136/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630383738322f3230313630342f3630383738322d32303136303430373139353130363632352d313235343234383232362e6a7067)

*那么，为什么浏览器有最大并发数呢？*

因为在以前网速慢、服务器硬件设备差，稍微流量大一些服务器就有些吃不消了。如果浏览器不设上限，那对一个网址同时加载10000+的资源数，那服务器肯定会爆。所以为了提高服务器的负载能力，保护服务器不受DDOS攻击，浏览器端便限制了**最大并发数**。

### 什么是域名收敛？

> 顾名思义，与域名发散完全相反。它是将静态资源只放在一个域名下面。

既然前面我们也说到了，域名发散可以突破浏览器的最大并发数，使资源加载更快，那么为什么又要把资源只放在一个域名下面呢？

因为在PC上网络快，硬件设备更好（可以存储很多的域名与IP地址的映射数据），所以它的 DNS 解析过程通常情况下就是几十ms。这个时候DNS解析并不浪费时间，静态资源可以用多个域名也无所谓。

但是在手机端或者是其他移动设备上就不一样了， 受3G和4G网络运营商的影响，一般在手机端上解析一个 DNS 会到1s+.，域名解析成本非常高。这个时候再用多个域名就不划算了，因为光花在DNS解析上的时间就很多了，得不偿失。

综合上面两个优化手段的比较和分析得出，PC上适用域名发散，移动web上适用域名收敛。

一句话，**域名发散 是pc时代的产物，域名收敛 是移动互联网时代的产物。**

## 什么是回源？

> 在搜索引擎中所谓的 **域名回源** 就是搜索引擎的蜘蛛在爬行的过程中直接抓取源地址上的内容，而不是抓取存在各个节点（CDN）上的缓存内容。

**常规的CDN都是回源的**。即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点是不会主动去源站拿的。

但源站内容有更新的时候，源站会主动把内容推送到CDN节点。

域名回源 一般是CDN领域的专业术语，通常情况下，是直接用IP进行回源的。但是如果客户源站有多个ip，并且ip地址会经常变化，对于CDN厂商来说，为了**避免经常更改配置（回源ip），会采用回源域名方式进行回源**。这样即使源站的ip变化了，也不影响原有的配置。

CDN本来是给我们的网站加速的，但是有时也会因为不合适的回源策略给服务器带来负担。

## 如何正确的回源？

前面提到了一旦CDN的内容过了有效期，我们向CDN获取静态资源的时候就会发生**CDN回源**。但是如果我们http头部中的Expires设置的时间过短，就会发生频繁的回源。如果过长，又不能保证用户的资源是最新的。

所以可以取一个中间值，如`cache-control: max-age=600`。

`cache-control: no-cache` 保证一定会发请求到服务器，但是没有修改也会用到本地缓存。它可以

但是还有一个地方影响缓存，就是http的ETag。我们先来梳理下HTTP缓存头部各个属性的作用。

**ETag** 是一个比cache-control更精准的控制缓存的属性。如果一秒内多次刷新，且时间没有超过max-age。那么Expires会忽略不看，去看 **Last-Modified**是否一样。

但是一比较都是同一秒发生的，这时候ETag就能排上用场了。因为是不同的修改记录，那么ETag的值不一样，这时候才会认定资源有变更，CDN需要回源。

所以他们的优先级是：

```bash
Pragma(是否no-cache) -> Cache-Control -> Expires -> Last-Modified -> ETag
```

综上所述，我们可以得出以下结论：

- 需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control
- 需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified（是否可以在静态资源文件名结尾加上md5加密的时间戳来解决呢？）
- 对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag
- 可以通过标识文件版本名、加长缓存时间的方式来减少304响应

***

参考文档：

[【前端性能】浅谈域名发散与域名收敛 · Issue \#1 · chokcoco/cnblogsArticle](https://github.com/chokcoco/cnblogsArticle/issues/1)

[域名发散\-\-前端优化\(三\) \- 前端的bigboom \- SegmentFault 思否](https://segmentfault.com/a/1190000004647665)

[HTTP缓存控制小结 \- 腾讯Web前端 IMWeb 团队社区 \| blog \| 团队博客](http://imweb.io/topic/5795dcb6fb312541492eda8c)

[由memoryCache和diskCache产生的浏览器缓存机制的思考 \- 朱萧默说的健身房 \- SegmentFault 思否](https://segmentfault.com/a/1190000011286027)

[CDN 回源之罪魁祸首\-etag \- 江湖一笑 \- ITeye博客](http://reckey.iteye.com/blog/2265276)](https://segmentfault.com/a/1190000004647665)